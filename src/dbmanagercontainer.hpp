/**
 *
 * \file dbmanagercontainer.hpp
 *
 * \brief Container to manipulate instances of DBManager
 */

#ifndef _DBMANAGERCONTAINER_HPP_
#define _DBMANAGERCONTAINER_HPP_

//STL includes
#include <string>
#include <exception>

#include "dbmanagerapi.hpp"	// For LIBDBMANAGER_API

//Library includes
#include "dbmanager.hpp"

/**
 * \class DBManagerContainer
 *
 * \brief Class to encapsulate a DBManager object (generated by class DBManagerFactory)
 * It will ensure the object is created (if not already existing), and the reference count is kepts up to date during the life cycle of DBManagerContainer
 * (DBManagerFactory::getInstance().freeDBManager() will be called when this DBManagerContainer is destructed)
 */
class LIBDBMANAGER_API DBManagerContainer {

	/**
	 * \brief swap function to allow implementing of copy-and-swap idom on members of type DBManagerContainer
	 *
	 * This function will swap all attributes of \p first and \p second
	 * See http://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom
	 *
	 * \param first The first object
	 * \param second The second object
	 */
	friend void swap(DBManagerContainer& first, DBManagerContainer& second);

public:
	/**
	 * \brief Class constructor
	 *
	 * Arguments are the same as DBManagerFactory::getDBManager()
	 *
	 * \param dbLocation The location, in a URL address, of the database to manage.
	 * \param configurationDescriptionFile The path to the configuration file to use for this database, or the configuration content directly provided as a std::string (no carriage return allowed in this case)
	 */
	DBManagerContainer(std::string dbLocation, std::string configurationDescriptionFile="");

	/**
	 * \brief Copy constructor
	 *
	 * \param other The object to copy from
	 */
	DBManagerContainer(const DBManagerContainer& other);

	/**
	 * \brief Class destructor
	 *
	 * Will ensure the underlying DBManager object reference count is decremented (and destructed by factory if reference count reaches 0)
	 */
	~DBManagerContainer();

	/**
	 * \brief Assignment operator
	 * 
	 * Private... we don't accept assignment, just instanciate a new object instead or use references
	 */
	DBManagerContainer& operator=(const DBManagerContainer& other) = delete;
	
	/**
	 * \brief Attribute getter
	 *
	 * Get a reference to the encapsulated DBManager object
	 *
	 * \return A reference to the encapsulated DBManager object
	 */
	inline DBManager& getDBManager() const {
		return this->dbm;
	}

private:
	std::string dbLocation;	/*!< The location URL of the database handled by the DBManager object encapsulated in this container */
	std::string configurationDescriptionFile;	/*!< The path to the configuration file to use for the encapsulated DBManager object in this container, or the configuration content directly provided as a std::string (no carriage return allowed in this case) */

	DBManager& dbm;	/*!< The DBManager object encapsulated in this container. Use DBManagerContainer::getDBManager() method to get access to this attribute */
};

#endif //_DBMANAGERCONTAINER_HPP_
